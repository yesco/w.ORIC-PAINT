<!DOCTYPE html>
<!-- w.ORIC-PAINT: Paints HIRES screen -->
<!-- This is a single file implementation, this to allow for ease of use/installation -->
<html>
<body text="black" bgcolor="white">

<div style='background-color: black; color:white; font-weight: bold; height: 1.5em;'>
  <tt>&nbsp;&nbsp;w.ORIC PAINT (<a href='#man' style='color:cyan'>manual</a>)</tt>
  <tt>&nbsp;&nbsp;https://yesco.github.io/w.ORIC-PAINT/</tt>
  <tt style='position:absolute;right:0'>CAPS&nbsp;&nbsp;</tt><br/>
</div>
<br/>


<style>
  .cmd {
      width: 1.8em; height: 2em;
      display: inline-block;
      text-align: center;
      place-content: center;
      font-weight: bold;
      color: black;
      background-color: white;
      //margin: 1px;
  }
  .sz {
      width: 2em;
      background-color: gray;
      color: white;
  }
</style>

<center>

<nobr style='text-align:top'>
<a class='cmd sel' title='brush thin'>&#8901;</a>
<a class='cmd sel' title='brush flat'>&#8213;</a>
<a class='cmd sel' title='brush cursive'>&#9585;</a>
<a class='cmd sel' title='brush down'>|</a>

<!-- &#9679; -->
<a class='cmd sel' title='brush circle'>&#11044;</a>
<!-- &#9632; -->
<a class='cmd sel' title='brush square'>&#9724;</a>
<tt>spray</tt>
<a class='cmd sel' title='spray 5'>&#9617;</span></a>
<a class='cmd sel' title='spray 10'>&#9618;</span></a>
<a class='cmd sel' title='spray 25'>&#9619;</span></a>
<a class='cmd sel' title='spray 100'>&#9607;</span></a>
</nobr><br/>

<nobr>
<tt>size</tt>
<a class='cmd sel sz' title='size 3'>3</a>
<a class='cmd sel sz' title='size 6'>6</a>
<a class='cmd sel sz' title='size 8'>8</a>
<a class='cmd sel sz' title='size 10'>10</a>
<a class='cmd sel sz' title='size 15'>15</a>
<a class='cmd sel sz' title='size 20'>20</a>
<a class='cmd sel sz' title='size 25'>25</a>
<a class='cmd sel sz' title='size 30'>30</a>
<a class='cmd sel sz' title='size 40'>40</a>
<a class='cmd sel sz' title='size 50'>50</a>
</nobr><br/>

<!-- draw colors -->
<nobr>
<a class='cmd sel' title='set' style='background-color:gray; color: white;'>clr</a>
<a class='cmd sel' title='clr' style='background-color:gray; color: white;'>set</a>
<a class='cmd sel' title='xor' style='background-color:gray; color: white;'>xor</a>
<a class='cmd sel' title='black' style='background-color:#000; color: white; border: 2px solid white;'>0</a>
<a class='cmd sel' title='red' style='background-color:#f00'>1</a>
<a class='cmd sel' title='green' style='background-color:#0f0'>2</a>
<a class='cmd sel' title='yellow' style='background-color:#ff0'>3</a>
<a class='cmd sel' title='blue' style='background-color:#00f'>4</a>
<a class='cmd sel' title='magnenta' style='background-color:#f0f'>5</a>
<a class='cmd sel' title='cyan' style='background-color:#0ff'>6</a>
<a class='cmd sel' title='white' style='background-color:#fff'>7</a>

<span style='width:2em;'>&nbsp;</span>
<a class='cmd sel' title='undo' style='background-color:black; width:3em; color:white; border:1px solid white;'>&#9003; (<span id='undocount'></span>)</a>

</nobr><br/>

<nobr>
<select id="size">
  <option value="1">1 px</option>
  <option value="2">2 px</option>
  <option value="3">3 px</option>
  <option value="4">4 px</option>
  <option value="5">5 px</option>
  <option value="6">6 px</option>
  <option value="7">7 px</option>
  <option value="8">8 px</option>
  <option value="9">9 px</option>
  <option value="10">10 px</option>
  <option value="11">11 px</option>
  <option value="12">12 px</option>
  <option value="15">15 px</option>
  <option value="20">20 px</option>
  <option value="25">25 px</option>
  <option value="30">30 px</option>
  <option value="40">40 px</option>
  <option value="50">50 px</option>
  <option value="cell">cell</option>
</select>

<select id="brush">
  <option value="thin">thin</option>
  <option value="flat">flat</option>
  <option value="down">down</option>
  <option value="cursive">cursive</option>
  <!--option value="watercolor">watercolor</option-->
  <option value="circle">circle</option>
  <!--option value="chinese">chinese</option-->
  <option value="square">square</option>
</select>

<!--TODO: rename to mode? unset, set, xor, move, spray.... -->
<select id="draw">
  <option value="spray 100">dutts</option>
  <option value="spray 50">spray 50%<x/option>
  <option value="spray 25">spray 25%</option>
  <option value="spray 15">spray 15%</option>
  <option value="spray 10">spray 10%</option>
  <option value="spray 5">spray  5%</option>
  <option value="spray 1">spray  1%</option>

  <option value="path">path</option>
  <option value="line">line</option>
  <option value="circle">circle</option>
  <option value="disc">disc</option>
  <option value="square">square</option>
  <option value="rect">rect</option>
  <option value="box">box</option>
  <option value="image">image</option>
</select>

<select id="inverse">
  <option value="off">norm</option>
  <option value="on">inv</option>
</select>

<select id="cell">
  <option value="-1">color</option>
  <option value="64">bgcol</option>
  <option value="192">invbg</option>
  <option value="127">fgcol</option>
  <option value="255">invfg</option>
</select>

<select id="action">
  <option value="" selected>action</option>
  <option value="load">load</option>
  <option value="tap">tap</option>
  <option value="xtap">xtap</option>
  <option value="import">import</option>
  <option value="erase">erase</option>
  <option value="draw 0">blk</option>
  <option value="draw 1">red</option>
  <option value="draw 2">grn</option>
  <option value="draw 3">yel</option>
  <option value="draw 4">blu</option>
  <option value="draw 5">mag</option>
  <option value="draw 6">cya</option>
  <option value="draw 7">wht</option>
  <option value="paper 0">BLK (WHT)</option>
  <option value="paper 1">RED (CYA)</option>
  <option value="paper 2">GRN (MAG)</option>
  <option value="paper 3">YEL (BLU)</option>
  <option value="paper 4">BLU (YEL)</option>
  <option value="paper 5">MAG (GRN)</option>
  <option value="paper 6">CYA (RED)</option>
  <option value="paper 7">WHT (BLK)</option>
  <option value="ink 0">blk (wht)</option>
  <option value="ink 1">red (cya)</option>
  <option value="ink 2">grn (mag)</option>
  <option value="ink 3">yel (blu)</option>
  <option value="ink 4">blu (yel)</option>
  <option value="ink 5">mag (grn)</option>
  <option value="ink 6">cya (red)</option>
  <option value="ink 7">wht (blk)</option>
</select>
</nobr>

<!-- red big ring char &#11093;
<a class='cmd sel' title='orange back arrow/undo?'>&#9664;</a>
<a class='cmd sel' title='orange forward arrow/undo?'>&#9654;</a>
<a class='cmd sel' title='erase left'>&#9003;</a>
<a class='cmd sel' title='big red x/close'>&#10060;</a>
<a class='cmd sel' title='counter-clock/redo?'>&#8634;</a>
<a class='cmd sel' title='clock-wise arrow/undo?'>&#8635;</a>
<a class='cmd sel' title='100'>&#128175;</a>
<button value="undo" onclick="javascript:undo();" title="undo" tooltip='undo' style='font-weight:bold;'>&#9664;</button>


-->

<br/>

<script>
// catch error as we have no console....
// window.onerror = function (event, souce, lineno, colon, error) { }
body.onerror= function(e, src, ln, colon, err) {
  alert('ERROR '+src+':'+ln+' - '+err);
}


// - read https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Sending_and_Receiving_Binary_Data

/* - TODO: use? this seems to clip at 4K under chrome/android/termux, neither claim low limit, lol
document.addEventListener('copy', function(e) {
  var str = 'cucumber';
  // You can ignore setting third parameter value
  //e.clipboardData.setData('text', str, true);
  e.clipboardData.setData("text", 'echo "'+btoa(cell)+'" | uudecode', true);
  e.preventDefault();
});
*/

function after(s, needle) {
  var r= s.split(needle);
  return r.length==2? r[1].trim(): null;
}

function before(s, needle) {
  var r= s.split(needle);
  return r.length==2? r[0].trim(): s;
}

function isprefix(pre, s) {
  return s.indexOf(pre)==0;
}

</script>

<style>
.fadeout {
  animation: fadeOut ease 2s forwards;
  background-color: black;
  color: white;
  zoom: 3;
  //mix-blend-mode: multiply;
}

@keyframes fadeOut {
  0%  { opacity: 1; }
  100% { opacity: 0; }
}
</style>

<div id="popover" class='fadeout' popover='manual' style='display: block; '>
  Welcome to ORIC Paint!
</div>

<canvas id="myCanvas" width="480" height="400" style="border:3px solid #d3d3d3; zoom:1; touch-action: none;">
Your browser does not support the HTML canvas tag.</canvas>
<br/>
<input type="file" id="files" multiple accept="*" style="display:none"/>


<nobr>
  <button id="load" type="button">Load</button>
  CMD: <input id="input" size=50 autocomplete=off autocorrect=off />
</nobr>

</center>

<h1>Debug:</h1>
<textarea id='log' rows="100" width="80" style="width:100%;height:90%;align:right;"></textarea>

<script>
// two variants:
// '#foo', or 'foo' => 1 dom element by id
// '.class' => []

function dom(name, optAction) {
  if (!(name.match(/[ >.]/)))
    return document.getElementById(name);
  return Array.from(document.querySelectorAll(name));
}

function log(s) {
  dom('log').value+= s+"\n";
}

var popover= dom('popover');

function runCommand(cmd) {
  // TODO: rewrite?
  popover.classList.remove('fadeout');
  popover.innerText= cmd;
  popover.offsetWidth; // lol triggers reflow!
  popover.classList.add('fadeout');
  // popover.showModal(); //doesn' do it?

  log('runCommand: '+cmd);

  saveUndo(); // TODO: if fail, remove?

  var param= after(cmd, ' ');
  var n= colornum(param);
  var nf= colornum(before(cmd, ' '));

  if (cmd.startsWith("draw ")) {
    drawink= n;
    return true;
  }
  if (cmd.startsWith('paper ') || cmd.startsWith('bg ')) {
    setpaperink(n, ink);
    updatehires();
    return true;
  }
  if (cmd.startsWith('ink ') || cmd.startsWith('fg ')) {
    setpaperink(paper, n);
    updatehires();
    return true;
  }

  if (cmd.startsWith('spray')) {
    dom('draw').value= cmd;
    return true;
  }

  if (cmd.startsWith('brush')) {
    if (param) {
      // TODO: brush circle 10? or just circle 10?
      dom('brush').value= param;
      if (dom('size').value=="1") dom('size').value= "8";
    } else {
      dom('brush').value= 'circle';
      dom('size').value= '10';
      dom('draw').value= 'spray 10';
    }
    return true;
  }

  if (cmd.startsWith('size ')) {
    dom('size').value= param;
    return true;
  }

  if (cmd.startsWith("erase")) {
    resethires();
    return true;
  }

  // TODO: redo?
  if (cmd.startsWith("undo")) {
    // twice because we just added one
    undo(); undo();
    return true;
  }

  // TODO: ctrl-L ?
  if (cmd.startsWith("redraw")) {
    updatehires();
    return true;
  }

  if (cmd.startsWith("load")) {
    load();
    return true;
  }

  if (cmd.startsWith("import")) { try {
    var img1 = new Image();

    // -- load and draw image, then convert it to ORIC
    img1.onload = function () {

      // scale image to maximize it, but keep proportions
      var dw= img1.naturalWidth, dh= img1.naturalHeight;
      var xy= dw/dh;
      if (xy > 240/200) 
        ctx.drawImage(img1, 0, 0, 240*w, 200*h/xy);
      else
        ctx.drawImage(img1, 0, 0, 240*w/xy, 200*h);

      // -- "convert" image to cells!
      var p= ctx.getImageData(0, 0, 240*w, 200*h);
      var pix= p.data;

    //convertToOric(pix);
      convertToOricJustAttributes(pix);
      //convertToOricJustPixels(pix);

      updatehires();
      saveUndo();
    };

    // CORS BullShit...
    // - https://stackoverflow.com/questions/22097747/how-to-fix-getimagedata-error-the-canvas-has-been-tainted-by-cross-origin-data
    // - https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
    // TODO: make my webserver be a proxy?
    //img1.crossOrigin = "Anonymous";
    //img1.src = 'https://thespider.oric.org/pics/oric_logo_colour_codes.gif';

    //img1.src = 'oric_logo_colour_codes.gif';

    // - clean 
    //img1.src= 'oric-logo-black-export.svg'; // not so good with atributes?
    img1.src= 'oric-logo-white-export.svg';

    // img1.src= '800px-Logo_Oric_Atmos.png’;
    //img1.src= 'oneps-00014.ppm';
    //img1.src= 'bbb.jpeg';

    // TODO: https://osdk.org/pics/magnetix_game.png
    // - many twilite tricks!
    return true;
  } catch(e) { alert(e); } }

  var xtap= cmd.startsWith("xtap");
  if (xtap || cmd.startsWith("tap")) {
    // This will save:
    // - header, filename
    // - hires screen
    // only for xtap
    // - 42 bytes garbage (?) 
    // - 3x40 chars of last 3 lines of text
    //   this one contains, hires attributes to show hires img, once loaded
    // TODO: maybe also include charset and
    // TODO: a basic loader?
    //
    // TODO: however, since we're not in hires mode, charset is "befuddled"!

    var header= (!xtap)?
    new Uint8Array([
      0x16, 0x16, 0x16, 0x16, 0x24, // sync
      0x00, 0x00, // any, any
      0x80, // 0x00=basic, 0x80=assembler/data
      0x00, // 0x00=stop,  0x80=basic autostart, 0xc7=asm autostart

      0xbf, 0x3f, // end address    0xbf3f HI-LO!
      0xa0, 0x00, // start address  0xa000 HI-LO! START

      0x00]) // any

      :

    // XTAP - xtended tap
    // TODO: charset, basic loader, etc...
    new Uint8Array([
      0x16, 0x16, 0x16, 0x16, 0x24, // sync
      0x00, 0x00, // any, any
      0x80, // 0x00=basic, 0x80=assembler/data
      0x00, // 0x00=stop,  0x80=basic autostart, 0xc7=asm autostart

      0xbf, 0xdf, // end address    0xbfdf HI-LO! END (end hires+42+3 text lines)
      0xa0, 0x00, // start address  0xa000 HI-LO! START

      0x00]);

    // TODO: picture part name?
    var filename= (param? param: "hires") + ".tap";
    var lost= "------------------------------------------"; // 42 bytes junk
    // These lines, unless we're in hires-mode, will display garbage!
    var text= "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x1e"
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\x1e"
    "ccccccccccccccccccccccccccccccccccccccc\x1e"; // last byte switches to hires!

    var blob = new Blob(
      (!xtap)?
        [header, filename, "\x00", cell, lost, text]
          :
        [header, filename, "\x00", cell, lost, text],
      {
        type: "binary",
      });

    // remove previous download link so we can use same name again!
    var d= dom("download");
    if (d) d.remove();

    // This seems to be a bad hacky way to get a download, lol, autoclick?
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.id= "download";
    a.download = filename;
    a.href = url;
    a.textContent = "Download "+ filename;
    a.click();
    //if the click() function dosen't work you can try using onclick() funcion like this
    //a.onclick();
    //document.getElementById("content").appendChild(a)

    // clear input field
    dom("input").value= "";
    return true;
  }

  // set clr xor - traditional drawing
  if (cmd.startsWith('clr')) { drawink= 0; return true; }
  if (cmd.startsWith('set')) { drawink= 1; return true; }
  if (cmd.startsWith('xor')) { drawink= 2; return true; }

  // everything else is tried as a color
  if (!isNaN(nf)) {
    log("draw "+ nf);
    drawink= 64+(nf&7);
    return true;
  }

  // fail
  alert("Unrecognized command: "+cmd);
  Dinput.select();
  return false;
}

function convertToOric(pix){
  // each line, backwards!
  ci= 0;
  for(var r=0; r<200; ++r) {

    // useful info?
    // a) how many different colors in the line?
    // b) are they blobs/cartonish or all mixed/dithered?
    // c) fine lines?
    var bg=0, fg=7;
    var colfreq= [0,0,0,0, 0,0,0,0];

    for(var c=39; c>=0; --c) {

      // extract 6 pixels
      var x= [0,0,0, 0,0,0];
      var or= 0;
      for(var i=0; i<6; ++i) {
        var f= x[i]= pixdomcolor(pix, w*4*(r*240*h+c*6+i));
        ++colfreq[f];
        or|= f;
      }

      // calculate resulting pixel cell
      var v= ( (x[0]?32:0) + (x[1]?16:0) + (x[2]?8:0) +
               (x[3]?4:0) + (x[4]?2:0) + (x[5]?1:0) + 64);
      var same= x.every( (z)=> (z==x[0]) );
      cell[ci+c]= v;
    }

    // find two most common colors
    var mx= Array.from(colfreq).sort( (a,b) => b-a );
    for(var i=7; i>=0; --i) {
      if (colfreq[i]==mx[0]) bg= i;
      if (colfreq[i]==mx[1]) fg= i;
    }
    cell[ci+0]= bg+16;
    cell[ci+1]= fg;

    log("row="+r+" bg="+bg+" fg="+fg+" freq="+colfreq.toString()+" max="+mx.toString());

    ci+= 40;
  }
}

function convertToOricJustAttributes(pix) {
  // each line, backwards!
  ci= 0;
  for(var r=0; r<200; ++r) {

    // useful info?
    // a) how many different colors in the line?
    // b) are they blobs/cartonish or all mixed/dithered?
    // c) fine lines?

    for(var c=39; c>=0; --c) {
      var x= [0,0,0, 0,0,0];
      var or= 0;
      for(var i=0; i<6; ++i) {
        // TODO: do avg? 
        // for now, just pick first, lol
        or|= (x[i]= pixdomcolor(pix, w*4*(r*240*h+c*6+i)));
      }

      // calculate resulting cell
      var v= ( (x[0]?32:0) + (x[1]?16:0) + (x[2]?8:0) +
               (x[3]?4:0) + (x[4]?2:0) + (x[5]?1:0) + 64);
      var same= x.every( (z)=> (z==x[0]) );
      // TODO: if same, maybe can consider other coding tech w attributes/inversion?
      cell[ci+c]= or+16; // make (avg) color background for this cell
    }

    ci+= 40;
  }
}

function convertToOricJustPixels(pix){
  // each line, backwards!
  ci= 0;
  for(var r=0; r<200; ++r) {

    for(var c=39; c>=0; --c) {
      var x= [0,0,0, 0,0,0];
      var or= 0;
      for(var i=0; i<6; ++i) {
        // TOOD: SHIT w*h pixels to process!
        // TODO: do avg? 
        // for now, just pick first, lol
        or|= (x[i]= pixcolor(pix, w*4*(r*240*h+c*6+i)));
      }

      // calculate resulting cell
      var v= ( (x[0]?32:0) + (x[1]?16:0) + (x[2]?8:0) +
               (x[3]?4:0) + (x[4]?2:0) + (x[5]?1:0) + 64);
      var same= x.every( (z)=> (z==x[0]) );
      // TODO: if same, maybe can consider other coding tech w attributes/inversion?
      cell[ci+c]= v;
    }

    ci+= 40;
  }
}

// prefer alt as full command to parse than
function runLink(e) {
  //log('runLink: title='+this.title+' t='+this.innerText);
  runCommand(this.title || this.innerText);
}

// make all color elements clickable as commands!
dom('.cmd').forEach( (x) => {
  x.onclick= runLink;
} );

// -- https://developer.mozilla.org/en-US/docs/Web/API/File_API/Using_files_from_web_applications

const Dfiles= dom('files'), Dload= dom('load');

function load() { Dfiles.click(); }

Dload.addEventListener('click', load, false);

Dfiles.addEventListener('change', async ()=>{
  var files= Dfiles.files;
  var f= files[0];
  //alert("File: "+f.name+' of '+f.size+' bytes');
  const buffer = await f.arrayBuffer();
  var b= new Uint8Array(buffer);

  // TODO: push as an alternative image, with it's own stack?
  saveUndo();
  var start= 14;
  // skip filename
  while(b[start]) ++start;
  ++start; // skip filename end \0

  // read hires
  var c= b.slice(start, 8000);
  cell= c;
  updatehires();

}, false);

/*
Dfiles.addEventListener('change', async (event) => {
  const buffer = await event.target.files[0].arrayBuffer()
  var b= new Uint8Array(buffer);
  alert(b.toString());
}, false)
*/

// TODO: create an overlay cell grid
// - https://stackoverflow.com/questions/36216561/create-canvas-over-another-canvas
// TODO: 

var Daction= dom("action"), DactionDef= Daction.value;

Daction.onchange= ()=> {
  var v= Daction.value;
  if (runCommand(v)) ;
  else alert("action.Not.Implemented.Yet: "+ Daction.value);
  Daction.value= DactionDef;
}

const w= 2, h= 2;
var canvas = dom("myCanvas");
var ctx = canvas.getContext("2d");

//const colors= ["black", "red", "lime", "yellow", "blue", "magenta", "cyan", "white"];
const colors= ["#000", "#f00", "#0f0", "#ff0", "#00f", "#f0f", "#0ff", "#fff"];

function colornum(t) {
  if (t==null) return NaN;
  t= t.trim().toLowerCase();
  var n= parseInt(t);
  if (!isNaN(n)) return n;

  if (isprefix(t, 'green')) return 2;
  if (isprefix(t, 'white')) return 7;
  if (isprefix(t, 'magnenta')) return 5;
  if (isprefix(t, 'cyan')) return 6;
  if (isprefix(t, 'yellow')) return 3;

  if (t=='black' || t=='k') return 3;
  if (t=='red'   || t=='r') return 1;
  if (t=='blue'  || t=='u') return 4;

  return NaN;
}

// store hires screen as array of cells
var cell= new Uint8Array(200*40);
var paper= 0, ink= colornum('red');
const DRAWINK=64;
var drawink= DRAWINK+colornum('yellow'); // draw ink is 0,1,2,3 or 128+colornum

// running data state for graphics during update
var x, y, ci, bg, fg;

function setpaperink(p, i) {
  //alert("set papper ink:"+p+" i:"+i);
  paper= p; ink= i;
  for(ci=0; ci<cell.length; ci+= 40) {
    cell[ci]  = paper+16;
    cell[ci+1]= ink;
  }
  updatehires();
}

function resethires() {
  ci=x=y= 0;
  bg= 0; fg= 7;
  cell.fill(ink);
  setpaperink(paper, ink);
  updatehires();
}

resethires();

function nextcell() {
  if (ci>= 240*40) return;

  var v= cell[ci];
  // colors reset every line
  if (ci%40==0) { bg=0; fg=7; x= 0; }

  var i= v&7;

  // hibit is invert colors
  var vl= v&127;

  if (vl<32) { // attributes
    //alert("vl= "+vl+" i="+i);
    // change color
    if (vl>= 0 && vl< 8) fg= i;
    if (vl>=16 && vl<24) bg= i;

    // draw current attr
    var b= colors[(v&128)? 7-bg: bg];
    //b= 'yellow'; // for debug set yellow
    ctx.fillStyle= b;
    ctx.fillRect(x, y, 6*w, h);
    x+= 6*w;

  } else { // pixels 32..63, 63..127

    var b= colors[(v&128)? 7-bg: bg];
    var f= colors[(v&128)? 7-fg: fg];

    // draw 6 pixels
    for(i=0; i<6; ++i) {
      ctx.fillStyle= (v&32)? f: b;
      ctx.fillRect(x, y, w, h);
      v <<= 1; x+= w;
    }

  }

  if (x>=240*w) { x=0; y+= h; }
  ++ci;
}

function updatehires() {
  x= 0; y= 0; ci= 0;
  while(ci<240*40)
    nextcell();
}

function partialupdate() {
  // only need to update the row
  // this will get right colors and effect
  var oy= Math.floor(ci/40);
  x= 0;
  y= 2*oy;
  ci= 40*oy;
  for(var i=40; i--;) nextcell();
}

// TODO: read image from data
// from - https://stackoverflow.com/questions/667045/get-a-pixel-from-html-canvas

function invert() {
  // get CanvasPixelArray
  var imgd = context.getImageData(x, y, width, height);
  var pix = imgd.data;

  // invert each pixel
  for (var i = 0, n = pix.length; i < n; i += 4) {
    pix[i  ] = 255 - pix[i  ]; // red
    pix[i+1] = 255 - pix[i+1]; // green
    pix[i+2] = 255 - pix[i+2]; // blue
    // i+3 is alpha (the fourth element)
  }

  // Draw ImageData at (x,y)
  context.putImageData(imgd, x, y);
}

// return oric 0-7 color from rgb!
// 0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magnenta, 6=cyan, 7=white
function pixcolor(pix, i) {
  var r= pix[i+0], g= pix[i+1], b= pix[i+2], alpha= pix[i+3];
  // simple!
  // TODO: threshold?
  return (r?1:0) + (g?2:0) + (b?4:0);
}

function pixdomcolor(pix, i) {
  var r= pix[i+0], g= pix[i+1], b= pix[i+2], alpha= pix[i+3];
  // simple!
  // TODO: threshold?
  return (r>127?1:0) + (g>127?2:0) + (b>127?4:0);
}

// - https://en.m.wikipedia.org/wiki/Grayscale
// gray: 0--255:ish
function pixgrayscale(pix, i) {
  // x = 0.299r + 0.587g + 0.114b
  var r= pix[i+0], g= pix[i+1], b= pix[i+2], alpha= pix[i+3];
  return Math.floor(0.299*r + 0.587*g + 0.114*b);
}

//ctx.beginPath();
//ctx.arc(25,25,15,0,2*Math.PI);
//ctx.stroke();
//ctx.fillStyle = "green";
//ctx.fillRect(x+=30,y,w,h);
//c.rect(x+=6, y, w, h);

//////////////////////////////////////////////////////////////////////
// - https://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html

// Set up mouse events for drawing
var drawing = false;
var currentPos = { x:0, y:0 };
var startPos = { x:0, y:0 };

// curset(ox, oy, f)
//   ox, oy is "oric coordinates"
//   f is 0=clear, 1=set, 2=xor, 3=move, 32+color= force color!
//
// TODO: combicolors, like brown? (red+yellow+blue!)

// TODO: ansi-color 6x6x6 rgb mapping?
// - https://en.m.wikipedia.org/wiki/ANSI_escape_code#8-bit
//
// ESC[38;5;⟨n⟩m Select foreground color
//       where n is a number from the table below
// ESC[48;5;⟨n⟩m Select background color
//   0-  7:  standard colors (as in ESC [ 30–37 m)
//   8- 15:  high intensity colors (as in ESC [ 90–97 m)
//  16-231:  6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)
// 232-255:  grayscale from dark to light in 24 steps

function curset(ox, oy, f) {
  ox= Math.floor(ox); oy= Math.floor(oy);
  if (ox<0 || oy<0 || ox>=240 || oy>=200) {
    ci= -1;
    return;
  }
  var cm= 32>>(ox%6);
  ci= Math.floor(ox/6) + oy*40;

  // don't set bits in paper attributes
  var v= cell[ci]&127;
  if (v>=16 && v<16+8) return;

  // steal ink cell and make it ours!
  if (v<8) cell[ci]= 64 | (cell[ci]&128);

  switch(f) {
  case 0: cell[ci] &= ~cm; break;
  case 1: cell[ci] |=  cm; break;
  case 2: cell[ci] ^=  cm; break;
  case 3: return;

  // >=DRAWINK over-write color
  // TODO: interaction with 128?
  default:
    if (f>=DRAWINK) {

      // -- find ink to set after
      // artifact: double shadow... lol

      var i= ci+1;

      // TODO: this doesn't work as good as you expect
      //   as we're cursetting many in same row...
      // TODO: only do on rightmost!
      //   tried, but funny, moving back in path creates
      //   an "undraw" effect and gets back what you had before!
      // TODO: do this after whole drawing motioned
      //   happened, on whole picture line by line.
      if (1 && f>=128) {
        // Act on untainted image!
        var oldcell= undoStack[undoStack.length-1];
        var afterink= -1;

        // find first left ink color, or beginning of screen
        while((i%40)!=0) {
          var c= oldcell[i]&127;
          if (c<8) { afterink=c; break; }
          --i;
        }
        // replicate that ink
        // TODO: corner-cases
        if ((oldcell[ci+1]&127)>=64 &&
            afterink != -1 &&
            afterink != f&7) {
          var c= cell[ci+1]= afterink || (oldcell[ci+1]&128);
          log('afterink: '+afterink);
        }
      }

      // set current drawink before
      i= ci-1; 
      while((i%40)!=0) {
        var c= cell[i]&127;

        // override other ink, or pixels
        if (c>=64 || c<8) {
          cell[i]= f&7;
          break;
        }
        // dont change background
        --i;
      }

      var v= cell[ci];

      // don't steal paper
      if (v>=16 && v<24) return;
      if (v>=128+16 && v<128+24) return;

      // steal ink cell and make it ours!
      if (v<8) cell[ci]= 64 | (cell[ci]&128);


      // draw pixel
      cell[ci] |= cm; return;
    }
  }
}

function changed(pos) {
  ox= Math.floor((pos.x+1)/2);
  oy= Math.floor((pos.y+1)/2);
  var v= 0+dom("cell").value;
  if (v>0) {
    curset(ox, oy, 3);
    cell[ci]= 0+v;
    partialupdate();
  } else 
    drawbrush();
}

function drawbrush() {
  var brush= dom("brush").value;
  var size= 0+dom("size").value;
  var draw= dom("draw").value;
  var spray= (draw.startsWith('spray')?
              0+after(draw, 'spray'):
              100)/100.0;
  var f= drawink;
  //var f= drawink==ink? 1: 16+drawink;
  //var f= drawink+16;
  
  switch(brush) {

  case 'thin':
    // TODO: do we want spray effect here?
    if (Math.random()<=spray) {
      curset(ox, oy, f);
      partialupdate();
    }
    break;

  case 'flat':
    // TODO: do we want spray effect here?
    var firstinrow= 128;
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) curset(ox-i, oy, f+firstinrow);
      firstinrow= 0;
    }
    partialupdate();
    break;

  case 'down':
    // TODO: do we want spray effect here?
    var firstinrow= 128;
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox, oy+i, f+firstinrow);
        partialupdate();
      }
    }
    break;

  case 'cursive':
    // TODO: do we want spray effect here?
    var firstinrow= 128;
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox-i, oy+i, f+firstinrow);
        partialupdate();
      }
    }
    break;

  case 'circle':
    var radius= size;
    var w= radius, h= radius;
    for(var r= -h; r<= +h; ++r) {
      // draw from right to left, not to smear attributes
      var firstinrow= 128;
      for(var c=+w; c>= -w; --c) {
        if (r*r+c*c<radius*radius
            && Math.random()<=spray) {
          curset(ox+c, oy+r, f+firstinrow);
          firstinrow= 0;
        }
      }
      partialupdate();
    }
    break;

  case 'square':
    var w= size, h= size;
    for(var r= -h; r<= +h; ++r) {
      var firstinrow= 128;
      for(var c= +w; c>= -w; --c) {
        if (Math.random()<=spray) {
          curset(ox+c, oy+r, f+firstinrow);
          firstinrow= 0;
        }
      }
      partialupdate();
    }
    break;

  }
}

// UNDO/REDO

var undoStack= [];

function saveUndo() {
  undoStack.push(new Uint8Array(cell));
  dom('undocount').textContent= ''+undoStack.length;
}

function undo() {
  if (!(undoStack.length)) return;
  cell= undoStack.pop();
  updatehires();
  dom('undocount').textContent= ''+undoStack.length;
}

// TODO: change this, no like...

canvas.addEventListener("mousedown", function (e) {
  saveUndo();
  drawing = true;
  currentPos= startPos = getMousePos(canvas, e);
  changed(startPos);
  return false;
}, false);

// good to draw a line, action at end?
canvas.addEventListener("mouseup", function (e) {
  drawing = false;
  return false;
}, false);
  
canvas.addEventListener("mousemove", function (e) {
  currentPos = getMousePos(canvas, e);
  changed(currentPos);
  return false;
}, false);

// Get the position of the mouse relative to the canvas
function getMousePos(canvasDom, mouseEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: mouseEvent.clientX - rect.left,
    y: mouseEvent.clientY - rect.top
  };
}


// Set up touch events for mobile, etc
canvas.addEventListener("touchstart", function (e) {
  mousePos = getTouchPos(canvas, e);
  //alert(mousePos);
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

canvas.addEventListener("touchend", function (e) {
  var mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
}, false);

canvas.addEventListener("touchmove", function (e) {
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

// Get the position of a touch relative to the canvas
function getTouchPos(canvasDom, touchEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: touchEvent.touches[0].clientX - rect.left,
    y: touchEvent.touches[0].clientY - rect.top
  };
}

// Prevent scrolling when touching the canvas
document.body.addEventListener("touchstart", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);

document.body.addEventListener("touchend", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);
document.body.addEventListener("touchmove", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);

//alert("all setup!");

// KEYBOARD

var Dinput= dom("input");

document.body.onkeypress= function(e) {
  Dinput.select();
  Dinput.dispatchEvent(e);
  return false;
}

Dinput.onsubmit= function(e) {
  alert(Dinput.value);
}

Dinput.onchange= function() {
  var cmd= Dinput.value;
  runCommand(cmd);
  Dinput.value= "";
  return false;
}

</script>

</body>

<script>
function allsame(six) {
}

// sixrgb= [7, 3, 1, 0, 2 5];
function encodesix(sixrgb) {
  if (sixrgb.every( (v)=> (v==sixrgb[0]) )) return { all: sixrgb[0] };

  // order by frequency, remove zeroes
  var colfreq= {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0};
  sixrgb.forEach( (v) => ++colfreq[v] );

  var mx= Array.from(colfreq).sort( (a,b) => b-a );
  while(mx.length && !(mx[mx.length-1])) mx.pop();

  // copy to modify, and tag with extra info
  var r= Array.from(sixrgb); 
  r.freq= colfreq;
  r.

  if (mx.length==1) { r.all= mx[0]; return r; }
  //if (r= seqcols(sixrgb)) return r; // TODO: matters? yes if we want to ignore?
  if (mx.length==2) { r.two= [mx[0], mx[1]]; return r; }
  // lefties?
  // rigthies?
  //if (r= onedom(sixrgb)) return r; // TODO: matters?
  r.freq= colfreq; return 
}

function step(state) {
  let [cost, [sixpix, nextsix, ...rest], bg, fg, revcode]= state;
}

</script>

<a name="man"></a>

<h1>Manual</h1>

<p>This is an ORIC HIRES SCREEN drawing program, it's web-based, but implements simple HIRES attributes non-blink/text/mix display of an HIRES screen.</p>

<p>By making attributes effect directly clear while touch-drawing on the screen, hopefully, allowing users to paint relatively unlimited. The <tt>undo</tt>-facility makes it easy to go back.</p>

<p>Features:
<ul>
<li>Unlimited <tt>undo</tt></li>
<li>free command line interaction, just type <tt>commands</tt> as seen</li>
<li>limited GUI-interaction, these actually just as just textual commands!</li>
<li><tt>paper blue</tt>, or <tt>ink red</tt> changes the first two columns</li>
<li><b>unlimited color</b> drawing (<tt>draw yellow</tt>)</li>
<li><tt>load</tt> and <tt>save</tt>, <tt>tap</tt>-files</li>
<li>limited <tt>import</tt> facility of any web-image, for testing</li>
</ul>
</p>

<h2>Brush</h2>

<p>There are a number of different brushes.</p>

<p>First, just try them out by selecting a <tt>brush</tt>, incidently, typing just <tt>brush</tt> will set a default: brush circle, size 10, spray 10%</p>

<p>They can be selected by clicking on their shapes, or typing:
<ul>
<li><tt>brush thin</tt> - basically a single pixel set</li>
<li><tt>brush line</tt> - a row of pixels</li>
<li><tt>brush cursive</tt> - pretends to be an old school ink pen/calligraphy(?)</li>
<li><tt>brush down</tt> - a bar of pixels</li>
<li><tt>brush circle</tt> - a Chinese round brush(?)</li>
<li><tt>brush square</tt> - a "square" brush, lol(?)</li>
</ul>
</p>

<p><b>Note:</b> brushes draw and set attributes to the left, so less artifacts are given by drawing right-to-left! It's highly recommended to use in combination with <tt>spray 20</tt> to get better result.</p>

<h2>Size</h2>

<p>Sizes of brushes, are in pixels wide, or radius, or square-"radius", given as <tt>size 1</tt>, <tt>size 3</tt>, ... up to <tt>size 50</tt>. However, you can specify whatever you like!</p>

<h2>Spray</h2>

<p>And, I guess it wouldn't be a paint-program if it didn't have brushes and <tt>spray</tt> command. This is explored more in detail in the section "Draw color". But it takes an argument of percentage, % of probability a pixel will set or not. This applies to all shapes of brushes.</p>

<p><tt>spray 50</tt> is quite heavy, and using higher value will give you more attribute clashes. Like using a real brush, the more you move it around, the more it "paints", i.e. sets pixels.</p>

<p><b>Note:</b> the more you pain, you'll notice that it creates more background color areas to the "left" of the what you're currently drawing. These are the ink-color attributes. This is at best interpret-able as a "shadow" and at worst an "artifact". ;-)</p>

<h2>Colors</h2>

<p>colors can be selected on the screen, or just written:
<ul>
<li><tt>paper blue</tt></li>
<li><tt>ink white</tt></li>
<li><tt>draw yellow</tt></li>
</p>

<ul>
<li><tt>0</tt>, or <tt>k</tt> or <tt>black</tt></li>
<li><tt>1</tt>, or <tt>r</tt> or <tt>red</tt></li>
<li><tt>2</tt>, or <tt>g</tt> or <tt>green</tt></li>
<li><tt>3</tt>, or <tt>y</tt> or <tt>yellow</tt></li>
<li><tt>4</tt>, or <tt>u</tt> or <tt>blue</tt></li>
<li><tt>5</tt>, or <tt>m</tt> or <tt>magenta</tt></li>
<li><tt>6</tt>, or <tt>c</tt> or <tt>cyan</tt></li>
<li><tt>7</tt>, or <tt>w</tt> or <tt>white</tt></li>
</ul>

<h3>Draw color</h3>

<p><tt>draw</tt> color is a new concept, in that it <b>allows</b>, and <i>assumes</i> unlimited color mixing. In practice, as we know ORIC is limited in this aspect. Nevertheless, a special version of "curset" taking an extended "fb" third parameter, apart from 0=unset, 1=set, 2=xor, 3=move, DRAWINK+color (64+color) will set an attribute in a cell before this pixel! Yes, this will "harm" the previously draw picture, but by using clever drawing methods good results may be achieved.</p>

<p>The preferred modes of drawing is <tt>thin</tt>, which is a single pixel set, or <tt>circle</tt> with <tt>size 10</tt> and <tt>spray</tt> with various fullness, like <tt>spray 20</tt> it randomly "curset"s 20% of the pixels. The more it moves the more pixels are being set, these are randomized thus giving interesting non-repeating patterns.</p>

<p>With higher degree of of size/spray/brush-types the effects of setting attributes gets more noticeable, creating "dark" background color zones, where attributes set the <tt>draw<?tt> color.</p>

<h2>Files</h2>

<p>You can <tt>load</tt> a tap-file, or <tt>save</tt> it with those commands. <tt>save filename</tt> will generate a file to be saved as "filename.tap" in the browser. This can then be loaded on an real ORIC, or in an emulator.</p>

<h2>Import</h2>

<p>There is a rudimentary command to <tt>import</tt> a given file, currently hard-coded. This currently stretches the image to maximize it's extent, keeping it's ratio intact. Then the image is resampled or converted to ORIC HIRES, currently it only have these experimental functions:
<ul>
<li>black-white</li>
<li>background attributes, rough 6-pixel-cell encoding</li>
<li>...</li>
</ul>
This implementation is constantly changing. For real better conversions I guess <b>libpipi</b> or <b>pict-conv</b> programs can be used.</p>

</html>

<!-- thinking about line attribute transitions:

Observing  line by itself:

aaa-aaa bbb-bbb ccc-ccc ddd-ddd = background attributes!
aaa-aab bab-bba ...             = paper ink
aaa-aaa aaa-aaa aaa-bbb bbb-bbb bbb-bbb bbb-ccc ccc-ccc = 
Pa      Ib      aaa-bbb Pb      Ic      bbb-ccc ccc-ccc

Ah, ir's a search-problem with many branches!
- cost, or rather least error result based


-->
